name: Build PAK

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

jobs:
  build:
    runs-on: windows-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          path: MyRomanceGuessWho

      - name: Download LSLib
        shell: pwsh
        run: |
          $releases = Invoke-RestMethod -Uri "https://api.github.com/repos/Norbyte/lslib/releases/latest"
          $asset = $releases.assets | Where-Object { $_.name -like "ExportTool-*.zip" } | Select-Object -First 1
          Write-Host "Downloading: $($asset.browser_download_url)"
          Invoke-WebRequest -Uri $asset.browser_download_url -OutFile lslib.zip
          Expand-Archive -Path lslib.zip -DestinationPath lslib
          
          # Find divine.exe
          Write-Host "LSLib contents:"
          Get-ChildItem -Path lslib -Recurse -Filter "divine.exe" | ForEach-Object {
              Write-Host "Found: $($_.FullName)"
          }

      - name: Build PAK
        shell: pwsh
        run: |
          $PAKNAME = "MyRomanceGuessWho"
          
          # Get absolute paths
          $WORKDIR = (Get-Location).Path
          $MODDIR = Join-Path $WORKDIR $PAKNAME
          $META = Join-Path $MODDIR "Mods/$PAKNAME/meta.lsx"
          
          # Find divine.exe
          $divine = Get-ChildItem -Path lslib -Recurse -Filter "divine.exe" | Select-Object -First 1
          if (-not $divine) {
              Write-Error "divine.exe not found in lslib"
              exit 1
          }
          $divinePath = $divine.FullName
          Write-Host "Using divine: $divinePath"
          
          Write-Host "Mod directory: $MODDIR"
          Write-Host "Reading metadata from: $META"
          
          # Parse XML properly to get ModuleInfo section
          [xml]$xml = Get-Content $META
          $moduleInfo = $xml.save.region.node.children.node | Where-Object { $_.id -eq "ModuleInfo" }
          
          $FOLDERVALUE = ($moduleInfo.attribute | Where-Object { $_.id -eq "Folder" }).value
          $UUIDVALUE = ($moduleInfo.attribute | Where-Object { $_.id -eq "UUID" }).value
          $NAMEVALUE = ($moduleInfo.attribute | Where-Object { $_.id -eq "Name" }).value
          $VERSION = ($moduleInfo.attribute | Where-Object { $_.id -eq "Version64" }).value
          
          Write-Host "Folder: $FOLDERVALUE"
          Write-Host "UUID: $UUIDVALUE"
          Write-Host "Name: $NAMEVALUE"
          Write-Host "Version: $VERSION"
          
          # Validate folder matches pak name
          if ($FOLDERVALUE -ne $PAKNAME) {
              Write-Error "Folder mismatch - $PAKNAME vs $FOLDERVALUE"
              exit 1
          }
          
          # Create temp directory with absolute path
          $TEMPDIR = Join-Path $WORKDIR "temp"
          New-Item -ItemType Directory -Path $TEMPDIR -Force | Out-Null
          $PAKPATH = Join-Path $TEMPDIR "$PAKNAME.pak"
          
          # Create mod pack using absolute paths
          Write-Host "Creating PAK file..."
          Write-Host "Source: $MODDIR"
          Write-Host "Destination: $PAKPATH"
          & $divinePath -g "bg3" --action "create-package" --source "$MODDIR" --destination "$PAKPATH" -l "all"
          
          if (-not (Test-Path $PAKPATH)) {
              Write-Error "Failed to create PAK file"
              exit 1
          }
          
          Write-Host "PAK created successfully"
          Get-Item $PAKPATH | Format-List Name, Length
          
          # Calculate MD5
          $MD5 = (Get-FileHash -Path $PAKPATH -Algorithm MD5).Hash.ToLower()
          Write-Host "MD5: $MD5"
          
          # Create info.json
          $info = @{
              mods = @(
                  @{
                      modName = $NAMEVALUE
                      UUID = $UUIDVALUE
                      folderName = $PAKNAME
                      version = $VERSION
                      MD5 = $MD5
                  }
              )
          }
          $infoPath = Join-Path $TEMPDIR "info.json"
          $info | ConvertTo-Json -Depth 3 | Set-Content $infoPath
          
          Write-Host "Created info.json"
          Get-Content $infoPath
          
          # Create zip
          Write-Host "Creating zip archive..."
          $ZIPPATH = Join-Path $WORKDIR "$PAKNAME.zip"
          Compress-Archive -Path "$TEMPDIR/*" -DestinationPath $ZIPPATH -Force
          
          Write-Host ""
          Write-Host "All done!"
          Get-Item $ZIPPATH | Format-List Name, Length

      - name: Upload ZIP artifact
        uses: actions/upload-artifact@v4
        with:
          name: MyRomanceGuessWho
          path: MyRomanceGuessWho.zip

      - name: Create Release
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v1
        with:
          files: MyRomanceGuessWho.zip
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
